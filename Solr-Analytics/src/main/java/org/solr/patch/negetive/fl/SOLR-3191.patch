Index: solr/core/src/java/org/apache/solr/search/ReturnFields.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/ReturnFields.java	(revision 1620514)
+++ solr/core/src/java/org/apache/solr/search/ReturnFields.java	(working copy)
@@ -16,7 +16,7 @@
  */
 package org.apache.solr.search;
 
-import java.util.*;
+import java.util.Set;
 
 import org.apache.solr.response.transform.DocTransformer;
 
@@ -27,6 +27,28 @@
  * @since solr 4.0
  */
 public abstract class ReturnFields {
+	  
+	  public final static String SCORE = "score";
+	  public final static char WILDCARD = '*';
+	  public final static char QUESTION_MARK = '?';
+	  public final static char OPEN_BRACKET = '[';
+	  public final static char CLOSE_BRACKET = ']';
+	  public final static char OPEN_PARENTHESIS = '(';
+	  public final static char CLOSE_PARENTHESIS = ')';
+	  public final static char LEFT_BRACE = '{';
+	  public final static char RIGHT_BRACE = '}';
+	
+	  public final static char HYPHEN = '-';
+	  public final static char QUOTE = '\'';
+	  public final static char DQUOTE = '\"';
+	  public final static char COLON = ':';
+	  public final static char POUND_SIGN = '#';
+	  public final static char DOT = '.';
+	  public final static char PLUS = '+';
+	
+	  public final static String ALIAS_VALUE_SEPARATOR = Character.toString(COLON);
+	  public final static String ALL_FIELDS = Character.toString(WILDCARD);
+	
   /**
    * Set of field names with their exact names from the lucene index.
    * <p>
Index: solr/core/src/java/org/apache/solr/search/SolrReturnFields.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SolrReturnFields.java	(revision 1620514)
+++ solr/core/src/java/org/apache/solr/search/SolrReturnFields.java	(working copy)
@@ -16,6 +16,12 @@
  */
 package org.apache.solr.search;
 
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.commons.io.FilenameUtils;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
@@ -25,7 +31,6 @@
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.response.transform.DocTransformer;
 import org.apache.solr.response.transform.DocTransformers;
@@ -34,405 +39,854 @@
 import org.apache.solr.response.transform.TransformerFactory;
 import org.apache.solr.response.transform.ValueSourceAugmenter;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
 /**
- * The default implementation of return fields parsing for Solr.
- */
-public class SolrReturnFields extends ReturnFields {
-  // Special Field Keys
-  public static final String SCORE = "score";
-
-  private final List<String> globs = new ArrayList<>(1);
-
-  // The lucene field names to request from the SolrIndexSearcher
-  private final Set<String> fields = new HashSet<>();
-
-  // Field names that are OK to include in the response.
-  // This will include pseudo fields, lucene fields, and matching globs
-  private Set<String> okFieldNames = new HashSet<>();
 
-  // The list of explicitly requested fields
-  // Order is important for CSVResponseWriter
-  private Set<String> reqFieldNames = null;
-  
-  protected DocTransformer transformer;
-  protected boolean _wantsScore = false;
-  protected boolean _wantsAllFields = false;
+ * Default implementation of {@link ReturnFields}.
+ * Encapsulates parsing logic of {@link CommonParams#FL} parameter and provides methods
+ * for indicating if a given field should be included in response or not.
+ */
 
-  public SolrReturnFields() {
-    _wantsAllFields = true;
-  }
+public final class SolrReturnFields extends ReturnFields {
+ 
 
-  public SolrReturnFields(SolrQueryRequest req) {
-    this( req.getParams().getParams(CommonParams.FL), req );
-  }
+  /** 
+   * FieldList parser state interface. Defines the behaviour that a given parser
+   * state must implement.
+   */
+  private abstract class ParserState {
+    
+    /**
+     * Callback method that lets this state process the n-th character.
+     * 
+     * @param aChar the char that is being processed.
+     * @param expressionBuffer the char buffer shared between states. Will hold the parsed expressions.
+     * @param request the current {@link SolrQueryRequest}.
+     * @param augmenters holds transformers.
+     * @throws SyntaxError in case this state detects a syntax error in the
+     *           character stream being processed.
+     */
+    protected abstract void onChar(char aChar, StringBuilder expressionBuffer, SolrQueryRequest request, DocTransformers augmenters)
+        throws SyntaxError;
+ 
 
-  public SolrReturnFields(String fl, SolrQueryRequest req) {
-//    this( (fl==null)?null:SolrPluginUtils.split(fl), req );
-    if( fl == null ) {
-      parseFieldList((String[])null, req);
+    /**
+     * Switches the parser to the new given state.
+     * 
+     * @param newState the {@link ParserState},
+     */
+   protected void switchTo(final ParserState newState) {
+      currentState = newState;
     }
-    else {
-      if( fl.trim().length() == 0 ) {
-        // legacy thing to support fl='  ' => fl=*,score!
-        // maybe time to drop support for this?
-        // See ConvertedLegacyTest
-        _wantsScore = true;
-        _wantsAllFields = true;
-        transformer = new ScoreAugmenter(SCORE);
-      }
-      else {
-        parseFieldList( new String[]{fl}, req);
-      }
-    }
-  }
-
-  public SolrReturnFields(String[] fl, SolrQueryRequest req) {
-    parseFieldList(fl, req);
-  }
-
-  private void parseFieldList(String[] fl, SolrQueryRequest req) {
-    _wantsScore = false;
-    _wantsAllFields = false;
-    if (fl == null || fl.length == 0 || fl.length == 1 && fl[0].length()==0) {
-      _wantsAllFields = true;
-      return;
+    
+    /**
+     * Resets the parser state.
+     * This method resets the char buffer too.
+     * 
+     * @param expressionBuffer the char buffer to reset.
+     */
+    protected void restartWithNewToken(final StringBuilder expressionBuffer) {
+      expressionBuffer.setLength(0);
+      currentState = detectingTokenType;
     }
-
-    NamedList<String> rename = new NamedList<>();
-    DocTransformers augmenters = new DocTransformers();
-    for (String fieldList : fl) {
-      add(fieldList,rename,augmenters,req);
+    
+    /**
+     * Determines if the specified character is permissible as the first character in a field list expression.
+     * A character may start a field list expression if and only if one of the following conditions is true:
+     * 
+     * <ul>
+     *  <li>Character.isJavaIdentifierStart(ch) returns true;</li>
+     *  <li>ch is pound sign, hash (#)</li>
+     * </ul>
+     * 
+     * @param ch ch the character to be tested.
+     * @return true if the character may start a field list expression; false otherwise.
+     */
+    protected boolean isFieldListExpressionStart(final char ch) {
+      return Character.isJavaIdentifierPart(ch) || ch == POUND_SIGN || ch == LEFT_BRACE;
     }
-    for( int i=0; i<rename.size(); i++ ) {
-      String from = rename.getName(i);
-      String to = rename.getVal(i);
-      okFieldNames.add( to );
-      boolean copy = (reqFieldNames!=null && reqFieldNames.contains(from));
-      if(!copy) {
-        // Check that subsequent copy/rename requests have the field they need to copy
-        for(int j=i+1; j<rename.size(); j++) {
-          if(from.equals(rename.getName(j))) {
-            rename.setName(j, to); // copy from the current target
-            if(reqFieldNames==null) {
-              reqFieldNames = new LinkedHashSet<>();
-            }
-            reqFieldNames.add(to); // don't rename our current target
-          }
-        }
-      }
-      augmenters.addTransformer( new RenameFieldTransformer( from, to, copy ) );
+    
+    /**
+     * Determines if the specified character may be part of a field list expression as other than the first character.
+     * A character may be part of a field list expression if any of the following are true:
+     * 
+     * <ul>
+     *  <li>Character.isJavaIdentifierPart(ch) returns true;</li>
+     *  <li>ch is pound sign, hash (#)</li>
+     *  <li>ch is colon (:)</li>
+     *  <li>ch is dot (.)</li>
+     * </ul>
+     * 
+     * @param ch ch the character to be tested.
+     * @return true if the character can be part of a field list expression; false otherwise.
+     */
+    protected boolean isFieldListExpressionPart(final char ch) {
+      return Character.isJavaIdentifierPart(ch) || ch == DOT || ch == COLON || ch == POUND_SIGN || ch == HYPHEN || ch == PLUS
+          || ch == LEFT_BRACE || ch == RIGHT_BRACE || ch == '!';
     }
+    
+    /**
+     * Determines if the specified character may be part of a SOLR function as other than the first character.
+     * A character may be part of a SOLR function if any of the following are true:
+     * 
+     * <ul>
+     *  <li>isSolrIdentifierPart(ch) returns true;</li>
+     *  <li>ch is comma (,)</li>
+     * </ul>
+     * 
+     * Note that passing this method char by char doesn't mean the whole function string will be valid.
+     * 
+     * @param ch ch the character to be tested.
+     * @return true if the character may start a SOLR fieldname; false otherwise.
+     */
+    protected boolean isSolrFunctionPart(final char ch) {
+      return isFieldListExpressionPart(ch) || ch == ',' || ch == '.' || ch == ' ' || ch == '\'' || ch == '\"' || ch == '='
+          || ch == '-' || ch == '/' || ch == PLUS;
+     }
 
-    if( !_wantsAllFields ) {
-      if( !globs.isEmpty() ) {
-        // TODO??? need to fill up the fields with matching field names in the index
-        // and add them to okFieldNames?
-        // maybe just get all fields?
-        // this would disable field selection optimization... i think thatis OK
-        fields.clear(); // this will get all fields, and use wantsField to limit
-      }
-      okFieldNames.addAll( fields );
-    }
+    
+    /**
+    * Checks if the given buffer contains a value that is a constant.
+     * 
+     * @param buffer the char buffer containing the current expression.
+     * @return true if the given buffer contains an expression which is actually a numeric constant.
+    */
+    protected boolean isConstantOrFunction(final StringBuilder buffer) {
+      if (buffer.indexOf("{!func") != -1) {
+        return true;
+       }
 
-    if( augmenters.size() == 1 ) {
-      transformer = augmenters.getTransformer(0);
-    }
-    else if( augmenters.size() > 1 ) {
-      transformer = augmenters;
-    }
-  }
 
-  // like getId, but also accepts dashes for legacy fields
-  String getFieldName(QueryParsing.StrParser sp) {
-    sp.eatws();
-    int id_start = sp.pos;
-    char ch;
-    if (sp.pos < sp.end && (ch = sp.val.charAt(sp.pos)) != '$' && Character.isJavaIdentifierStart(ch)) {
-      sp.pos++;
-      while (sp.pos < sp.end) {
-        ch = sp.val.charAt(sp.pos);
-        if (!Character.isJavaIdentifierPart(ch) && ch != '.' && ch != '-') {
-          break;
+     int offset = buffer.lastIndexOf(ALIAS_VALUE_SEPARATOR);
+      offset = (offset == -1) ? 0 : offset + 1;
+      for (int i = offset; i < buffer.length(); i++) {
+        final char ch = buffer.charAt(i);
+        if (!(Character.isDigit(ch) || ch == HYPHEN || ch == PLUS || ch == DOT)) {
+          return false;
         }
-        sp.pos++;
-      }
-      return sp.val.substring(id_start, sp.pos);
-    }
-
-    return null;
-  }
-
-  private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {
-    if( fl == null ) {
-      return;
-    }
-    try {
-      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);
+       }
+      return true;
+     }
+   }
+ 
 
-      for(;;) {
-        sp.opt(',');
-        sp.eatws();
-        if (sp.pos >= sp.end) break;
+  /**
+   * An exclusion glob token is being parsed.
+   * Activated in case an exclusion glob is detected (e.g. -pipp*,-*ippo).
+   */
+  final ParserState collectingExclusionGlob = new ParserState() {
+	    @Override
+	    public void onChar(final char aChar, final StringBuilder expressionBuffer, final SolrQueryRequest request,
+	        final DocTransformers augmenters) throws SyntaxError {
+	      if (!isFieldListExpressionPart(aChar)) {
+	        if (aChar == WILDCARD || aChar == QUESTION_MARK) {
+	          expressionBuffer.append(aChar);
+	         }
+	       onExclusionGlobExpression(expressionBuffer);
+	        restartWithNewToken(expressionBuffer);
+	      } else {
+	        expressionBuffer.append(aChar);
+	       }
 
-        int start = sp.pos;
+	     }
 
-        // short circuit test for a really simple field name
-        String key = null;
-        String field = getFieldName(sp);
-        char ch = sp.ch();
+	  };
+ 
+ /**
+   * An exclusion (literal) token is being parsed.
+   * Activated in case an exclusion literal field name is detected (e.g. -pipp*,-*ippo).
+   */
+  final ParserState collectingExclusionToken = new ParserState() {
+	    @Override
+	    public void onChar(final char aChar, final StringBuilder buffer, final SolrQueryRequest request,
+	        final DocTransformers augmenters) throws SyntaxError {
+	      if (aChar == WILDCARD || aChar == QUESTION_MARK)
+	      {
+	        buffer.append(aChar);
+	        switchTo(collectingExclusionGlob);
+	      } else if (!isFieldListExpressionPart(aChar)) {
+	        if (isConstantOrFunction(buffer)) {
+	          onFunction(buffer, augmenters, request);
+	        } else {
+	          onExclusionLiteralFieldName(buffer);
+	        }
+	        restartWithNewToken(buffer);
+	      } else {
+	        buffer.append(aChar);
+	       }
 
-        if (field != null) {
-          if (sp.opt(':')) {
-            // this was a key, not a field name
-            key = field;
-            field = null;
-            sp.eatws();
-            start = sp.pos;
-          } else {
-            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {
-              addField(field, key, augmenters, false);
-              continue;
-            }
-            // an invalid field name... reset the position pointer to retry
-            sp.pos = start;
-            field = null;
-          }
-        }
+	     }
 
-        if (key != null) {
-          // we read "key : "
-          field = sp.getId(null);
-          ch = sp.ch();
-          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
-            rename.add(field, key);
-            addField(field, key, augmenters, false);
-            continue;
-          }
-          // an invalid field name... reset the position pointer to retry
-          sp.pos = start;
-          field = null;
-        }
+	  };
+  
+  /**
+   * A transformer token is being parsed.
+   * Activated in case a transformer is detected (e.g. [docid][explain]).
+   */
+	  final ParserState collectingTransformer = new ParserState() {
+		    @Override
+		    public void onChar(final char aChar, final StringBuilder expressionBuffer, final SolrQueryRequest request,
+		        final DocTransformers augmenters) throws SyntaxError {
+		      expressionBuffer.append(aChar);
+		      if (aChar == CLOSE_BRACKET) {
+		        onTransformer(expressionBuffer, request, augmenters);
+		        restartWithNewToken(expressionBuffer);
+		      }
+		     }
 
-        if (field == null) {
-          // We didn't find a simple name, so let's see if it's a globbed field name.
-          // Globbing only works with field names of the recommended form (roughly like java identifiers)
+		  };
+ 
+  /**
+   * An inclusion glob token is being parsed.
+   * Activated in case an inclusion glob is detected (e.g. pipp*,*ippo).
+   */
+		  final ParserState collectingInclusionGlob = new ParserState() {
+			    @Override
+			    public void onChar(final char aChar, final StringBuilder buffer, final SolrQueryRequest request,
+			        final DocTransformers augmenters) {
+			      if (isFieldListExpressionPart(aChar) || aChar == WILDCARD || aChar == QUESTION_MARK) {
+			        buffer.append(aChar);
+			      } else {
+			        onInclusionGlob(buffer);
+			        restartWithNewToken(buffer);
+			      }
+			     }
 
-          field = sp.getGlobbedId(null);
-          ch = sp.ch();
-          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
-            // "*" looks and acts like a glob, but we give it special treatment
-            if ("*".equals(field)) {
-              _wantsAllFields = true;
-            } else {
-              globs.add(field);
-            }
-            continue;
-          }
+			  };
+  
+  /**
+   * A token that has been classified as function is being parsed.
+   */
+			  final ParserState collectingFunction = new ParserState() {
+				    private int openParenthesis;
+				    
+				    @Override
+				   public void onChar(final char aChar, final StringBuilder expressionBuffer, final SolrQueryRequest request,
+				        final DocTransformers augmenters)
+				       throws SyntaxError {
+				      switch (aChar) {
+				        case OPEN_PARENTHESIS:
+				          openParenthesis++;
+				          expressionBuffer.append(aChar);
+				           break;
 
-          // an invalid glob
-          sp.pos = start;
-        }
+				        case CLOSE_PARENTHESIS:
+				          openParenthesis--;
+				          expressionBuffer.append(aChar);
+				         if (openParenthesis == 0) {
+				            onFunction(expressionBuffer, augmenters, request);
+				           restartWithNewToken(expressionBuffer);
+				          }
+				          break;
+				        default:
+				          if (isSolrFunctionPart(aChar)) {
+				           expressionBuffer.append(aChar);
+				          }
+				       }
 
-        String funcStr = sp.val.substring(start);
+				     }
 
-        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?
-        // This is identical to localParams syntax except it uses [] instead of {!}
+				 };
+ 
 
-        if (funcStr.startsWith("[")) {
-          Map<String,String> augmenterArgs = new HashMap<>();
-          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), "[", ']');
-          sp.pos += end;
+  /**
+   * A token that has been classified as function is being parsed.
+  */
+				 final ParserState collectingLiteral = new ParserState() {
+					    private int quoteCount;
+					    
+					    @Override
+					    public void onChar(final char aChar, final StringBuilder expressionBuffer, final SolrQueryRequest request,
+					       final DocTransformers augmenters) throws SyntaxError {
+					     switch (aChar) {
+					        case QUOTE:
+					        case DQUOTE:
+					          quoteCount++;
+					          expressionBuffer.append(aChar);
+					          if (quoteCount % 2 == 0) {
+					            onFunction(expressionBuffer, augmenters, request);
+					            restartWithNewToken(expressionBuffer);
+					           }
 
-          // [foo] is short for [type=foo] in localParams syntax
-          String augmenterName = augmenterArgs.remove("type");
-          String disp = key;
-          if( disp == null ) {
-            disp = '['+augmenterName+']';
-          }
+					          break;
+					        default:
+					         if (isSolrFunctionPart(aChar)) {
+					           expressionBuffer.append(aChar);
+					           }
 
-          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );
-          if( factory != null ) {
-            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );
-            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );
-          }
-          else {
-            // unknown transformer?
-          }
-          addField(field, disp, augmenters, true);
-          continue;
-        }
+					      }
+					    }
+					  };
+  
+  /**
+   * Parser state activated when a token maybe several things: inclusion (literal or glob) and function.
+   */
+					  ParserState maybeInclusionLiteralOrGlobOrFunction = new ParserState() {
+						    @Override
+						    public void onChar(final char aChar, final StringBuilder builder, final SolrQueryRequest request,
+						        final DocTransformers augmenters) throws SyntaxError {
+						      switch (aChar) {
+						        case OPEN_PARENTHESIS:
+						          switchTo(collectingFunction);
+						          currentState.onChar(aChar, builder, request, augmenters);
+						          break;
+						        case QUOTE:
+						        case DQUOTE:
+						          switchTo(collectingLiteral);
+						          currentState.onChar(aChar, builder, request, augmenters);
+						          break;
+						        case QUESTION_MARK:
+						        case WILDCARD:
+						         builder.append(aChar);
+						         switchTo(collectingInclusionGlob);
+						         break;
+						        case OPEN_BRACKET:
+						          builder.append(aChar);
+						         switchTo(collectingTransformer);
+						          break;
+						        default:
+						          if (!isFieldListExpressionPart(aChar)) {
+						            if (isConstantOrFunction(builder)) {
+						              onFunction(builder, augmenters, request);
+						             } else {
 
+						              onInclusionLiteralExpression(builder, augmenters, true, true);
+						             }
 
-        // let's try it as a function instead
-        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);
-        Query q = null;
-        ValueSource vs = null;
+						            restartWithNewToken(builder);
+						          } else {
+						            builder.append(aChar);
+						           }
 
-        try {
-          if (parser instanceof FunctionQParser) {
-            FunctionQParser fparser = (FunctionQParser)parser;
-            fparser.setParseMultipleSources(false);
-            fparser.setParseToEnd(false);
+						      }
+						    }
+						  };
+  /**
+   * Initial parser state: we know nothing about next (or the first) token.
+   */
+						  final ParserState detectingTokenType = new ParserState() {
+							    @Override
+							    public void onChar(final char aChar, final StringBuilder builder, final SolrQueryRequest request,
+							        final DocTransformers augmenters) throws SyntaxError {
+							      switch (aChar) {
+							        case HYPHEN:
+							          switchTo(collectingExclusionToken);
+							         break;
+							        case OPEN_BRACKET:
+							          builder.append(aChar);
+							          switchTo(collectingTransformer);
+							          break;
+							        case QUESTION_MARK:
+							        case WILDCARD:
+							         builder.append(aChar);
+							          switchTo(collectingInclusionGlob);
+							          break;
+							        case QUOTE:
+							        case DQUOTE:
+							          switchTo(collectingLiteral);
+							          currentState.onChar(aChar, builder, request, augmenters);
+							         break;
+							        default:
+							          if (isFieldListExpressionStart(aChar)) {
+							            builder.append(aChar);
+							            switchTo(maybeInclusionLiteralOrGlobOrFunction);
+							           }
+							      }
+							    }
+							  };
+  
+  // Parser state (initial state is "detecting token type").
+  private ParserState currentState = detectingTokenType;
+  
+  /**
+   * Field list parsing entry point.
+   * 
+   * @param request the current request.
+   * @param fieldLists the field list(s) that will be parsed.
+   * @throws SyntaxError in case the given field lists contains syntax errors.
+   */
+  void parse(final SolrQueryRequest request, final String... fieldLists) throws SyntaxError {
+	    final DocTransformers augmenters = new DocTransformers();
+	    final StringBuilder charBuffer = new StringBuilder();
+	    for (String fieldList : fieldLists) {
+	      for (int i = 0; i < fieldList.length(); i++) {
+	        final char aChar = fieldList.charAt(i);
+	        currentState.onChar(aChar, charBuffer, request, augmenters);
+	     }
+	 
 
-            q = fparser.getQuery();
+	      currentState.onChar(' ', charBuffer, request, augmenters);
+	    }
+	    
+	    if (augmenters.size() == 1) {
+	      transformer = augmenters.getTransformer(0);
+	    } else if (augmenters.size() > 1) {
+	      transformer = augmenters;
+	    }
+	  }
+	  
+	  private boolean wantsAllFields;
+	  
+	  private Set<String> luceneFieldNames;
+	  private Set<String> requestedFieldNames;
+	 
+	  private Set<String> inclusions;
+	  private Set<String> exclusions;
+	 private Set<String> inclusionGlobs;
+	  private Set<String> exclusionGlobs;
+	  
+	  protected DocTransformer transformer;
+	  
+	  private final Map<String,Boolean> cache = new HashMap<String,Boolean>();
+ 
 
-            if (fparser.localParams != null) {
-              if (fparser.valFollowedParams) {
-                // need to find the end of the function query via the string parser
-                int leftOver = fparser.sp.end - fparser.sp.pos;
-                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
-              } else {
-                // the value was via the "v" param in localParams, so we need to find
-                // the end of the local params themselves to pick up where we left off
-                sp.pos = start + fparser.localParamsEnd;
-              }
-            } else {
-              // need to find the end of the function query via the string parser
-              int leftOver = fparser.sp.end - fparser.sp.pos;
-              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
-            }
-          } else {
-            // A QParser that's not for function queries.
-            // It must have been specified via local params.
-            q = parser.getQuery();
+  /**
+   * Builds a new {@link SolrReturnFields} with no data.
+   * Basically it returns everything (i.e. *).
+   */
+  public SolrReturnFields() {
+    this((String[]) null, null);
+  }
+ 
+  /**
+   * Builds a new {@link SolrReturnFields} with the current request.
+   * The {@link CommonParams#FL} is used to get the field list(s).
+   * 
+   * @param request the current request.
+   */
+  public SolrReturnFields(final SolrQueryRequest request) {
+    this(request.getParams().getParams(CommonParams.FL), request);
+  }
+  
+  /**
+   * Builds a new {@link SolrReturnFields} with the given data.
+   * The {@link CommonParams#FL} is used to get the field list(s).
+   * 
+   * @param fl the field list(s).
+   * @param request the current request.
+   */
+  public SolrReturnFields(final String[] fl, final SolrQueryRequest request) {
+    if (fl == null || fl.length == 0) {
+      wantsAllFields = true;
+    } else {
+         try {
 
-            assert parser.getLocalParams() != null;
-            sp.pos = start + parser.localParamsEnd;
-          }
-          funcStr = sp.val.substring(start, sp.pos);
+          parse(request, fl);
+        } catch (SyntaxError exception) {
+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, exception.getMessage(), exception);
+        }
+      
+      wantsAllFields |= ((inclusions == null && inclusionGlobs == null) && (exclusions == null && exclusionGlobs == null));
+    }
+  }
+  
+  /**
+   * Builds a new {@link SolrReturnFields} with the given data.
+   * 
+   * @param fl the field list.
+   * @param request the current request.
+   */
+  public SolrReturnFields(final String fl, final SolrQueryRequest request) {
+    this(new String[] {fl}, request);
+  }
+  
+  /**
+   * Processes a function.
+   * In case the given string cannot be processed as a valid function, then a search is done on the schema
+   * in order to see if a field with such name exists. 
+   * 
+   * @param expressionBuffer the char buffer that holds the function expression.
+   * @param augmenters the transformer collector.
+   * @param request the current request.
+   * @throws SyntaxError in case the function has a wrong syntax or there's no function neither a field with such name.
+   */
+  void onFunction(final StringBuilder expressionBuffer, final DocTransformers augmenters, final SolrQueryRequest request)
+      throws SyntaxError {
+    
+    final String alias = getExpressionAlias(expressionBuffer);
+    final String function = getExpressionValue(expressionBuffer);
+ 
+    final QParser parser = QParser.getParser(function, FunctionQParserPlugin.NAME, request);
+    Query q = null;
+ 
 
+    try {
+      if (parser instanceof FunctionQParser) {
+        FunctionQParser fparser = (FunctionQParser) parser;
+        fparser.setParseMultipleSources(false);
+        fparser.setParseToEnd(false);
+        q = fparser.getQuery();
+      } else {
+        // A QParser that's not for function queries.
+        // It must have been specified via local params.
+        q = parser.getQuery();
+        assert parser.getLocalParams() != null;
+      }
+      
+      final ValueSource vs = (q instanceof FunctionQuery) ? ((FunctionQuery) q).getValueSource() : new QueryValueSource(q, 0.0f);
+      
+      String aliasThatWillBeUsed = alias;
+ 
 
-          if (q instanceof FunctionQuery) {
-            vs = ((FunctionQuery)q).getValueSource();
-          } else {
-            vs = new QueryValueSource(q, 0.0f);
-          }
+      if (alias == null) {
+        final SolrParams localParams = parser.getLocalParams();
+        if (localParams != null) {
+          aliasThatWillBeUsed = localParams.get("key");
+        }
+      }
+      
+      aliasThatWillBeUsed = (aliasThatWillBeUsed != null) ? aliasThatWillBeUsed : function;
+ 
+      // Collect the function as it would be a literal
+      onInclusionLiteralExpression(expressionBuffer, augmenters, false, false);
+ 
 
-          if (key==null) {
-            SolrParams localParams = parser.getLocalParams();
-            if (localParams != null) {
-              key = localParams.get("key");
-            }
-          }
+      augmenters.addTransformer(new ValueSourceAugmenter(aliasThatWillBeUsed, parser, vs));
+    } catch (SyntaxError exception) {
+      if (request.getSchema().getFieldOrNull(function) != null) {
+        // OK, it was an oddly named field
+        onInclusionLiteralExpression(expressionBuffer, augmenters, true, true);
+      } else {
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+            "Error parsing fieldname: " + exception.getMessage(), exception);
+      }
+    }
+  }
+  
+  /**
+   * Processes a literal field name that will be included in response. 
+   * Important: calling this method cleans any previous requested exclusion list 
+   * (both literals and globs).
+   * 
+   * @param expressionBuffer the char buffer that holds the literal expression.
+   * @param augmenters the accumulator for requested transformers.
+   */
+  void onInclusionLiteralExpression(final StringBuilder expressionBuffer, final DocTransformers augmenters, final boolean rename,
+      final boolean isRealField) {
+    final String alias = getExpressionAlias(expressionBuffer);
+    final String fieldname = getExpressionValue(expressionBuffer);
+    final String requestedName = (alias != null) ? alias : fieldname;
+    
+    requestedFieldNames().add(requestedName);
+    inclusions().add(requestedName);
+ 
 
-          if (key==null) {
-            key = funcStr;
-          }
-          addField(funcStr, key, augmenters, true);
-          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );
-        }
-        catch (SyntaxError e) {
-          // try again, simple rules for a field name with no whitespace
-          sp.pos = start;
-          field = sp.getSimpleString();
+    if (SCORE.equals(fieldname)) {
+      augmenters.addTransformer(new ScoreAugmenter((alias == null) ? SCORE : alias));
+    } else {
+ 
 
-          if (req.getSchema().getFieldOrNull(field) != null) {
-            // OK, it was an oddly named field
-            addField(field, key, augmenters, false);
-            if( key != null ) {
-              rename.add(field, key);
-            }
-          } else {
-            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Error parsing fieldname: " + e.getMessage(), e);
-          }
-        }
+      if (isRealField) {
+        luceneFieldNames().add(fieldname);
+        clearExclusions();
+      }
+ 
 
-        // end try as function
+      if (alias != null && rename) {
+        augmenters.addTransformer(new RenameFieldTransformer(fieldname, alias, true));
+      }
+     }
+   }
 
-      } // end for(;;)
-    } catch (SyntaxError e) {
-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Error parsing fieldname", e);
-    }
+  
+  /**
+   * Processes a literal value that will be excluded in response. 
+   * Note that if some inclusion (literal or glob) has been explicity requested, then this method won't
+   * have any effect.
+   * 
+   * @param fieldNameBuffer the buffer that hold the exclusion literal.
+   * @throws SyntaxError in case the  
+   */
+  void onExclusionLiteralFieldName(final StringBuilder fieldNameBuffer) throws SyntaxError {
+    if ((inclusions == null || inclusions.isEmpty()) && (inclusionGlobs == null || inclusionGlobs.isEmpty())) {
+      if (getExpressionAlias(fieldNameBuffer) == null)
+      {
+        wantsAllFields = false;
+        exclusions().add(getExpressionValue(fieldNameBuffer));
+      }
+     }
   }
+  
+  /**
+   * Processes a transformer token. 
+   * 
+   * e.g. [docid]; [shard]; greeting:[value v='hello']; [mytrans5 jf=pinprojectid if=type:Projects mf=project_accessibilitytype]
+   * 
+   * @param expressionBuffer the char buffer that holds the transformer expression.
+   * @param request the current {@link SolrQueryRequest}.
+   * @param augmenters the transformer collector for the current request.
+   * @throws SyntaxError in case of invalid syntax.
+   */
+  void onTransformer(final StringBuilder expressionBuffer, final SolrQueryRequest request, final DocTransformers augmenters)
+	      throws SyntaxError {
+		  if(expressionBuffer!=null){
+		   String fl_Content=expressionBuffer.toString();
+			if(fl_Content.contains("[") && fl_Content.contains("]")){
+							
+				if(fl_Content.indexOf("[")==0){
+					 //Logic to Parse Custom Transformers containing token like (:) inside the expression
+					
+					  final Map<String,String> augmenterCustomArgs = new HashMap<String,String>();
+					  QueryParsing.parseLocalParams(expressionBuffer.toString(), 0, augmenterCustomArgs, request.getParams(), "[", CLOSE_BRACKET);
+					  final String augmenterCustomName = augmenterCustomArgs.remove("type");
+					  final String customDisp='['+augmenterCustomName+']';
+					  final TransformerFactory customFactory = request.getCore().getTransformerFactory(augmenterCustomName);
+				      if( customFactory != null ) {
+				      MapSolrParams augmenterCustomParams = new MapSolrParams( augmenterCustomArgs );
+				      augmenters.addTransformer( customFactory.create(customDisp, augmenterCustomParams, request) );
+					
+				}
+				}else if(fl_Content.indexOf("[")>0 && fl_Content.contains(":[")){
+					//Logic to Parse In_Built Transformers
+					
+				    final String alias = getExpressionAlias(expressionBuffer);
+				    final String transfomerExpression = getExpressionValue(expressionBuffer);
+				    final Map<String,String> augmenterArgs = new HashMap<String,String>();
+				    QueryParsing.parseLocalParams(transfomerExpression, 0, augmenterArgs, request.getParams(), "[", CLOSE_BRACKET);
+				    final String augmenterName = augmenterArgs.remove("type");
+				    final String aliasThatWillBeUsed = (alias != null) ? alias : OPEN_BRACKET + augmenterName + CLOSE_BRACKET;
+				    final TransformerFactory factory = request.getCore().getTransformerFactory(augmenterName);
+				    if (factory != null) {
+				    augmenters.addTransformer(factory.create(aliasThatWillBeUsed, new MapSolrParams(augmenterArgs), request));
+				    onInclusionLiteralExpression(expressionBuffer, augmenters, false, false);	
+							
+							}
+						}
 
-  private void addField(String field, String key, DocTransformers augmenters, boolean isPseudoField)
-  {
-    if(reqFieldNames==null) {
-      reqFieldNames = new LinkedHashSet<>();
-    }
-    
-    if(key==null) {
-      reqFieldNames.add(field);
-    }
-    else {
-      reqFieldNames.add(key);
-    }
+					}
 
-    if ( ! isPseudoField) {
-      // fields is returned by getLuceneFieldNames(), to be used to select which real fields
-      // to return, so pseudo-fields should not be added
-      fields.add(field);
-    }
+				}
+			}
 
-    okFieldNames.add( field );
-    okFieldNames.add( key );
-    // a valid field name
-    if(SCORE.equals(field)) {
-      _wantsScore = true;
+  
+  /**
+   * Processess an inclusion glob.
+   * Basically here we have same rules as
+   * {@link #onInclusionLiteralExpression(StringBuilder, DocTransformers, boolean, boolean)}
+   * 
+   * No aliasing is supported. No exception is raised (for retrocompatibility) but aliases are silently ignored. 
+   * 
+   * That is because we don't know how many actual fields will be matched
+   * by the glob expression.
+   * 
+   * @param bufferChar the character buffer that holds the current (glob) expression.
+   */
+  void onInclusionGlob(final StringBuilder bufferChar) {
+    final String glob = getExpressionValue(bufferChar);
+ 
 
-      String disp = (key==null) ? field : key;
-      augmenters.addTransformer( new ScoreAugmenter( disp ) );
+    if (!ALL_FIELDS.equals(glob)) {
+      inclusionGlobs().add(glob);
+      clearExclusions();
+    } else {
+      // Special case: * is seen as an inclusion glob
+      wantsAllFields = ((exclusions == null || exclusions.isEmpty()) && (exclusionGlobs == null || exclusionGlobs.isEmpty()));
     }
   }
-
-  @Override
-  public Set<String> getLuceneFieldNames()
-  {
-    return (_wantsAllFields || fields.isEmpty()) ? null : fields;
+  
+  /**
+   * Processes an exclusion glob. 
+   * Note that 
+   * 
+   * - if some inclusion (literal or glob) has been explicity requested, then this method won't
+   * have any effect.
+   * - if an alias has been specified it will be silently ignored
+   * - if the expression is a * (i.e. -*) then it will be silently ignored.
+   * 
+   * @param expressionBuffer the glob expression buffer.
+   */
+  void onExclusionGlobExpression(final StringBuilder expressionBuffer) {
+    if (getExpressionAlias(expressionBuffer) == null) {
+      final String glob = getExpressionValue(expressionBuffer);
+      
+      if (!ALL_FIELDS.equals(glob) && (inclusions == null || inclusions.isEmpty())
+          && (inclusionGlobs == null || inclusionGlobs.isEmpty())) {
+          wantsAllFields = false;
+          exclusionGlobs().add(glob);
+      }
+     }
+   }
+ 
+   @Override
+  public Set<String> getLuceneFieldNames() {
+    return (wantsAllFields || (luceneFieldNames == null || luceneFieldNames.isEmpty())) ? null : luceneFieldNames;
+   }
+ 
+   @Override
+   public Set<String> getRequestedFieldNames() {
+    if (wantsAllFields || requestedFieldNames == null || requestedFieldNames.isEmpty()) {
+       return null;
+     }
+    return requestedFieldNames;
   }
-
+  
   @Override
-  public Set<String> getRequestedFieldNames() {
-    if(_wantsAllFields || reqFieldNames==null || reqFieldNames.isEmpty()) {
-      return null;
+  public boolean wantsField(final String name) {
+    Boolean mustInclude = cache.get(name);
+    if (mustInclude == null) // first time request for this field
+    {
+      if ((exclusions == null || exclusions.isEmpty()) && (exclusionGlobs == null || exclusionGlobs.isEmpty())) {
+        mustInclude = wantsAllFields() || (inclusions != null && inclusions.contains(name))
+            || (inclusionGlobs != null && wildcardMatch(name, inclusionGlobs));
+      } else {
+        mustInclude = !((exclusions != null && exclusions.contains(name)) || (exclusionGlobs != null && wildcardMatch(name,
+            exclusionGlobs)));
+      }
+      cache.put(name, mustInclude);
     }
-    return reqFieldNames;
+    return mustInclude;
   }
   
   @Override
-  public boolean hasPatternMatching() {
-    return !globs.isEmpty();
+  public boolean wantsAllFields() {
+    return wantsAllFields;
   }
-
+  
   @Override
-  public boolean wantsField(String name)
-  {
-    if( _wantsAllFields || okFieldNames.contains( name ) ){
-      return true;
+  public boolean wantsScore() {
+    return inclusions != null && inclusions.contains(SCORE);
+   }
+   
+   @Override
+   public boolean hasPatternMatching() {
+    return inclusionGlobs != null && !inclusionGlobs.isEmpty();
+   }
+ 
+   @Override
+  public DocTransformer getTransformer() {
+    return transformer;
+  }
+  
+  /**
+   * Performs a wildcard match between the given (field) name and the glob list.
+   * 
+   * @param name the (field) name.
+   * @param globs the glob list.
+   * @return true if at least one expression in the list matches the given field name.
+   */
+  private boolean wildcardMatch(final String name, final Set<String> globs) {
+    for (final String glob : globs) {
+      if (FilenameUtils.wildcardMatch(name, glob)) {
+         return true;
+       }
+     }
+     return false;
+   }
+   
+
+  /**
+   * Returns the expression alias found in given bufferChar.
+   * The alias (if exists) is delimited by colon. If there's not such char then null is returned
+   * meaning that there's no alias.
+   * 
+   * @param bufferChar the buffer that contains the current expression.
+   * @return the expression alias or null if no alias is found.
+   */
+  private String getExpressionAlias(final StringBuilder bufferChar)
+   {
+    final int indexOfColon = bufferChar.indexOf(ALIAS_VALUE_SEPARATOR);
+    return indexOfColon == -1 ? null : bufferChar.substring(0, indexOfColon);
+   }
+
+  
+  /**
+   * Returns the expression value found in given bufferChar.
+   * The value (if alias exists) starts next to colon (which is the ending char of the alias).
+   * If there's no alias, all buffer content is supposed to be a value. 
+   * 
+   * @param bufferChar the buffer that contains the current expression.
+   * @return the expression value.
+   */
+  private String getExpressionValue(final StringBuilder bufferChar) {
+    final int indexOfColon = bufferChar.indexOf(ALIAS_VALUE_SEPARATOR);
+    return indexOfColon == -1 ? bufferChar.toString() : bufferChar.substring(indexOfColon + 1);
+  }
+  
+  /**
+   * Clears any collected exclusion (both literal and globs).
+   */
+  private void clearExclusions() {
+    if (exclusions != null) {
+      exclusions.clear();
     }
-    for( String s : globs ) {
-      // TODO something better?
-      if( FilenameUtils.wildcardMatch(name, s) ) {
-        okFieldNames.add(name); // Don't calculate it again
-        return true;
-      }
+    
+    if (exclusionGlobs != null) {
+      exclusionGlobs.clear();
+    }
+   }
+ 
+
+  /**
+   * Lazily creates the set that will hold inclusions.
+   * 
+   * @return the set that will hold inclusions.
+   */
+  private Set<String> inclusions() {
+    if (inclusions == null) {
+      inclusions = new HashSet<String>();
+    }
+    return inclusions;
+   }
+
+  
+  /**
+   * Lazily creates the set that will hold inclusion globs.
+   * 
+   * @return the set that will hold inclusions globs
+   */
+  private Set<String> inclusionGlobs() {
+    if (inclusionGlobs == null) {
+      inclusionGlobs = new HashSet<String>();
     }
-    return false;
+    return inclusionGlobs;
   }
   
-  @Override
-  public boolean wantsAllFields()
-  {
-    return _wantsAllFields;
+  /**
+   * Lazily creates the set that will hold exclusions.
+   * 
+   * @return the set that will hold exclusions.
+   */
+  private Set<String> exclusions() {
+    if (exclusions == null) {
+      exclusions = new HashSet<String>();
+    }
+    return exclusions;
   }
-
-  @Override
-  public boolean wantsScore()
-  {
-    return _wantsScore;
+  
+  /**
+   * Lazily creates the set that will hold exclusion globs.
+   * 
+   * @return the set that will hold exclusion globs.
+   */
+  private Set<String> exclusionGlobs() {
+    if (exclusionGlobs == null) {
+      exclusionGlobs = new HashSet<String>();
+    }
+    return exclusionGlobs;
   }
-
-  @Override
-  public DocTransformer getTransformer()
-  {
-    return transformer;
+  
+  /**
+   * Lazily creates the set that will hold lucene field names.
+   * 
+   * @return the set that will hold lucene field names.
+   */
+  private Set<String> luceneFieldNames() {
+    if (luceneFieldNames == null) {
+      luceneFieldNames = new HashSet<String>();
+    }
+    return luceneFieldNames;
+  }
+  
+  /**
+   * Lazily creates the set that will hold requested field names.
+   * 
+   * @return the set that will hold requested field names.
+   */
+  private Set<String> requestedFieldNames() {
+    if (requestedFieldNames == null) {
+      requestedFieldNames = new LinkedHashSet<String>();
+    }
+    return requestedFieldNames;
   }
-}
+
+    }
Index: solr/core/src/test/org/apache/solr/search/ReturnFieldsTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/ReturnFieldsTest.java	(revision 1620514)
+++ solr/core/src/test/org/apache/solr/search/ReturnFieldsTest.java	(working copy)
@@ -50,12 +50,12 @@
     assertU(adoc("id","1", "text",v,  "text_np", v, "#foo_s", v));
     v = "now cow";
     assertU(adoc("id","2", "text",v,  "text_np", v));
+    assertU(adoc("id", "3", "name", "This is a name", "title", "This is a title", "weight", "1.43"));
     assertU(commit());
   }
 
   @Test
   public void testCopyRename() throws Exception {
-
     // original
     assertQ(req("q","id:1", "fl","id")
         ,"//*[@numFound='1'] "
@@ -64,7 +64,7 @@
         );
     
     // rename
-    assertQ(req("q","id:1", "fl","xxx:id")
+    assertQ(req("q", "id:1", "fl", "xxx:id")
         ,"//*[@numFound='1'] "
         ,"*[count(//doc/str)=1] "
         ,"*//doc[1]/str[1][.='1'] "
@@ -167,7 +167,7 @@
 
   @Test
   public void testManyParameters() {
-    ReturnFields rf = new SolrReturnFields( req("fl", "id name", "fl", "test subject", "fl", "score") );
+    final ReturnFields rf = new SolrReturnFields(req("fl", "id name", "fl", "test subject", "fl", "score"));
     assertTrue( rf.wantsScore() );
     assertTrue( rf.wantsField( "id" ) );
     assertTrue( rf.wantsField( "name" ) );
@@ -226,6 +226,21 @@
     assertFalse(rf.wantsField("xxx"));
     assertFalse(rf.wantsAllFields());
     assertEquals( "mydocid", rf.getTransformer().getName() );
+    
+    rf = new SolrReturnFields( req("fl", "greeting:[value v='hello']") );
+    assertFalse( rf.wantsScore() );
+    assertTrue(rf.wantsField("greeting"));
+    assertFalse( rf.wantsField( "id" ) );
+    assertFalse(rf.wantsField("xxx"));
+    assertFalse(rf.wantsAllFields());
+    assertEquals( "greeting", rf.getTransformer().getName() );
+    
+    rf = new SolrReturnFields( req("fl", "[mytrans5 jf=pinprojectid if=type:Projects mf=project_accessibilitytype]") );
+    assertFalse( rf.wantsScore() );
+    assertFalse( rf.wantsField( "id" ) );
+    assertFalse(rf.wantsField("xxx"));
+    assertFalse(rf.wantsAllFields());
+    assertEquals( "mytrans5", rf.getTransformer().getName() );
 
     rf = new SolrReturnFields( req("fl", "[docid][shard]") );
     assertFalse( rf.wantsScore() );
@@ -330,9 +345,9 @@
             ,"//str[@name='id'][.='1']"
             ,"//arr[@name='#foo_s']/str[.='how now brown cow']"
             );
-
   }
 
+  @Test
   public void testWhitespace() {
     Random r = random();
     final int iters = atLeast(30);
@@ -354,16 +369,238 @@
       ReturnFields rf = new SolrReturnFields(req("fl", fl));
 
       assertFalse("score ("+fl+")", rf.wantsScore());
-
-      assertTrue("id ("+fl+")", rf.wantsField("id"));
-      assertTrue("foo_i ("+fl+")", rf.wantsField("foo_i"));
-
-      assertEquals("aliasId ("+fl+")", aliasId, rf.wantsField("aliasId"));
-      assertEquals("aliasFoo ("+fl+")", aliasFoo, rf.wantsField("aliasFoo"));
+      
+      if (aliasId) {
+        assertEquals("aliasId (" + fl + ")", aliasId, rf.wantsField("aliasId"));
+      } else {
+        assertTrue("id (" + fl + ")", rf.wantsField("id"));
+      }
+      
+      if (aliasFoo) {
+        assertEquals("aliasFoo (" + fl + ")", aliasFoo, rf.wantsField("aliasFoo"));
+      } else {
+        assertTrue("foo_i (" + fl + ")", rf.wantsField("foo_i"));
+      }
 
       assertFalse(rf.wantsField("xxx"));
       assertFalse(rf.wantsAllFields());
     }
   }
+  
+  @Test
+  public void testReturnAllRealFields() {
+    final String[] expressions = {
+        "*",
+        "* name", "name *",
+        "* -*", "-* *",
+        "* *me", "*me *",
+        "* *e", "*e *",
+        "[invalid transformer] [another invalid transformers] -ignored:exclusion -ignored:exclusionglob*"
+    };
+    
+    assertQueryResponseCorrectness(expressions, new Expectation() {
+      @Override
+      public boolean score() {
+        return false;
+      }
+      
+      @Override
+      public boolean id() {
+        return true;
+      }
+      
+      @Override
+      public boolean title() {
+        return true;
+      }
+      
+      @Override
+      public boolean name() {
+        return true;
+      }
+      
+      @Override
+      public boolean weight() {
+        return true;
+      }
+      
+      @Override
+      public boolean returnFieldsWantsAllFields() {
+        return true;
+      }
+    });
+  }
+  
+  @Test
+  public void testReturnOnlyName()
+  {
+    final String[] expressions = {
+        "name",
+        "*me", "na*", "n*e", "nam?", "n?m?",
+        "-id -title -weight",
+        "-id -title -weight name", "name -id -title -weight", "-id name -title -weight",
+        "-id -title -weight na*", "na* -id -title -weight", "-id na* -title -weight",
+        "-id name", "name -id",
+        "-id *me", "*me -id",
+        "-title name", "name -title",
+        "-title n*e", "n*e -title"
+    };
+    
+    assertQueryResponseCorrectness(expressions, new Expectation() {
+      @Override
+      public boolean weight() {
+        return false;
+      }
+      
+      @Override
+      public boolean title() {
+        return false;
+      }
+      
+      @Override
+      public boolean score() {
+        return false;
+      }
+      
+      @Override
+      public boolean returnFieldsWantsAllFields() {
+        return false;
+      }
+      
+      @Override
+      public boolean name() {
+        return true;
+      }
+      
+      @Override
+      public boolean id() {
+        return false;
+      }
+    });
+  }
+  
+  @Test
+  public void testReturnOnlyNameAndTitle()
+  {
+    final String[] expressions = {
+        "*e",
+        "*me titl?", "na* *le", "n*e t*e", "nam? titl?", "t?tl* n?m?",
+        "name title", "title name",
+        "-id -weight",
+        "-weigh* -i?",
+        "-weigh* -i? na* t*", "titl? n?m? -weigh* -i?",
+        "-weigh* -i? name title", "title name -weigh* -i?"
+    };
+    
+    assertQueryResponseCorrectness(expressions, new Expectation() {
+      @Override
+      public boolean weight() {
+        return false;
+      }
+      
+      @Override
+      public boolean title() {
+        return true;
+      }
+      
+      @Override
+      public boolean score() {
+        return false;
+      }
+      
+      @Override
+      public boolean returnFieldsWantsAllFields() {
+        return false;
+      }
+      
+      @Override
+      public boolean name() {
+        return true;
+      }
+      
+      @Override
+      public boolean id() {
+        return false;
+      }
+    });
+  }
+  
+  @Test
+  public void testReturnAllRealFieldsExceptName()
+  {
+    final String[] expressions = {
+        "-name",
+        "* -name", "-name *",
+        "-*me", "-na*", "-n*e", "-nam?", "-n?m?", "-nam*",
+        "id title weight",
+        "id title weight -name", "-name id title weight", "id -name title weight",
+        "id title weight -na*", "-na* id title weight", "id -na* title weight"
+    };
+    
+    assertQueryResponseCorrectness(expressions, new Expectation() {
+      @Override
+      public boolean weight() {
+        return true;
+      }
+      
+      @Override
+      public boolean title() {
+        return true;
+      }
+      
+      @Override
+      public boolean score() {
+        return false;
+      }
+      
+      @Override
+      public boolean returnFieldsWantsAllFields() {
+        return false;
+      }
+      
+      @Override
+      public boolean name() {
+        return false;
+      }
+      
+      @Override
+      public boolean id() {
+        return true;
+      }
+    });
+  }
 
-}
+  private void assertQueryResponseCorrectness(
+      final String[] fieldListExpressions,
+      final Expectation expectation) {
+    for (final String expression : fieldListExpressions) {
+      final SolrQueryRequest request = req(CommonParams.Q, "id:3", CommonParams.FL, expression);
+      assertQ(request
+          , "//*[@numFound='1'] "
+          , expectation.score()
+              ? "*[count(//doc/float[@name='" + ReturnFields.SCORE + "'])=1] "
+              : "*[count(//doc/float[@name='" + ReturnFields.SCORE + "'])=0] "
+          , expectation.id()
+              ? "//doc/str[@name='id']/text()=3"
+              : "*[count(//doc/str[@name='id'])=0] "
+          , expectation.title()
+              ? "//doc/str[@name='title']/text()= 'This is a title'"
+              : "*[count(//doc/str[@name='title'])=0] "
+          , expectation.name()
+              ? "//doc/str[@name='name']/text()= 'This is a name'"
+              : "*[count(//doc/str[@name='name'])=0] "
+          , expectation.weight()
+              ? "//doc/float[@name='weight']/text()=1.43"
+              : "*[count(//doc/float[@name='weight'])=0] ");
+      
+      final ReturnFields rf = new SolrReturnFields(request);
+      assertTrue(rf.wantsScore() == expectation.score());
+      assertTrue(rf.wantsAllFields() == expectation.returnFieldsWantsAllFields());
+      assertNull(rf.getTransformer());
+      assertTrue(rf.wantsField("id") == expectation.id());
+      assertTrue(rf.wantsField("name") == expectation.name());
+      assertTrue(rf.wantsField("title") == expectation.title());
+      assertTrue(rf.wantsField("weight") == expectation.weight());
+    }
+  }
+}
\ No newline at end of file
Index: solr/core/src/test/org/apache/solr/search/TestPseudoReturnFields.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/TestPseudoReturnFields.java	(revision 1620514)
+++ solr/core/src/test/org/apache/solr/search/TestPseudoReturnFields.java	(working copy)
@@ -17,20 +17,18 @@
 
 package org.apache.solr.search;
 
-import org.apache.solr.SolrTestCaseJ4;
-import org.apache.solr.schema.SchemaField;
-
-import org.apache.commons.lang.StringUtils;
-
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import java.util.List;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.List;
 import java.util.Random;
 
+import org.apache.commons.lang.StringUtils;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.schema.SchemaField;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
 public class TestPseudoReturnFields extends SolrTestCaseJ4 {
 
   // :TODO: datatypes produced by the functions used may change
@@ -158,7 +156,7 @@
             req("q","*:*", "rows", "1", "fl","val_i")
             ,"//result[@numFound='5']"
             ,"//result/doc/int[@name='val_i']"
-            
+
             ,"//result/doc[count(*)=1]"
             );
   }
